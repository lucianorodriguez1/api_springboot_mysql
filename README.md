# Sistema estudiantil SpringBoot y MySQL

Sistema realizado con el objetivo de tener documentado la conexion de MySQL con Spring Boot.

ACLARACION: No se usa lombok.

Diagrama entidad relacion (DER) que cree de mi sistema:

## Instalar dependencias
* spring-boot-starter-data-jpa 
* spring-boot-starter-web (Spring Web)
* mysql-connector-j (Desde el instalador se puede agregar MySQL Driver)
* spring-boot-starter-test
* spring-boot-starter-validation (agregar validaciones a los atributos de las clases)
* modelmapper

## Variables de entorno
* DB_URL = url de donde se encuentra la base de datos
* DB_USERNAME = nombre del usuario de la base de datos
* DB_PASSWORD = contrasenia del usuario de la base de datos

## Pasos
1. Agregar las tres variables de base de 
datos en el application.properties.
2. Tener la base de datos creada. 
3. Configurar el RUN para que se ejecuta siempre el archivo MAIN. Esto
se cambia en Edit Configuration -> Aplication -> Main Class -> Poner la ubicacion del archivo main.
4. Crear entidades dentro de carpeta entities con todo lo necesario para crear
las entidaders, relaciones, atributos, etc de la base de datos.


## Material 
Link al video de youtube donde pude obtener mucho informacion :
https://www.youtube.com/watch?v=9XoaU5IMkRY&t=457s

Documentacion de Jakarta:
https://jakarta.ee/learn/docs/jakartaee-tutorial/current/persist/persistence-intro/persistence-intro.html
que es la que vamos a usar en las entidades.

Tips para agregar anotaciones a las relaciones entre clases :
https://medium.com/devdomain/mastering-spring-database-relationship-annotations-161cb8232619

Tips para de Column para poner en cada Entity.
https://jakarta.ee/specifications/persistence/2.2/apidocs/javax/persistence/column

Anotaciones de Jakarta Validation:
https://jakarta.ee/specifications/bean-validation/3.0/apidocs/jakarta/validation/constraints/package-summary?utm_source=chatgpt.com 

Informacion sobre modelmapper basica:
https://www.geeksforgeeks.org/java/how-to-use-modelmapper-in-spring-boot-with-example-project/



@COLUMN
*   columnDefinition = (Optional) The SQL fragment that is used when generating the DDL for the column.
* 	insertable = (Optional) Whether the column is included in SQL INSERT statements generated by the persistence provider.
* 	length = (Optional) The column length.
*   name = (Optional) The name of the column.
*   nullable = (Optional) Whether the database column is nullable.
*   precision = (Optional) The precision for a decimal (exact numeric) column.
*   scale = (Optional) The scale for a decimal (exact numeric) column.
*   table = (Optional) The name of the table that contains the column.
*   unique = (Optional) Whether the column is a unique key.
*   updatable = (Optional) Whether the column is included in SQL UPDATE statements generated by the persistence provider.

metodos de ResponseEntity:
* ok()	Respuesta 200 OK sin body
* ok(body)	Respuesta 200 OK con body
* status(HttpStatus status)	Permite definir manualmente el status
* created(URI location)	Respuesta 201 Created con header Location
* accepted()	Respuesta 202 Accepted
* noContent()	Respuesta 204 No Content
* badRequest()	Respuesta 400 Bad Request
* notFound()	Respuesta 404 Not Found
* internalServerError()	Respuesta 500 Internal Server Error

En la clase Materia de entities dejo informacion al respecto.

El JpaRepository incluye por defectos los metodos para conectarse a la base de datos:

* save(S entity) — guardar o actualizar una entidad.
* saveAll(Iterable<S> entities) — guardar varias entidades.
* findById(ID id) — buscar por ID (retorna Optional<T>).
* findAll() — recuperar todos los registros.
* findAllById(Iterable<ID> ids) — buscar múltiples IDs.
* count() — contar registros.
* existsById(ID id) — verificar existencia por ID.
* deleteById(ID id), delete(T entity), deleteAll(...)
* findAll(Pageable pageable) — paginación.
* flush() — sincronizar cambios pendientes con la base de datos.
* saveAndFlush(S entity), saveAllAndFlush(Iterable<S> entities) — guardar y vaciar el estado inmediatamente.
* Operaciones por lotes como deleteInBatch(...), deleteAllInBatch().

Además, extiende otros interfaces como PagingAndSortingRepository y QueryByExampleExecutor, lo que permite paginación, ordenamiento y consultas por ejemplo.

Anotacion importante para evitar ciclos en relaciones bidireccionales : 
* @JsonIgnore

RECORDAR:
Poner los get, set y constructor vacio en las entidades para que hibernateJPA
interactue con la base de datos.

Al crear las exccepciones se empieza usando una clase general para controlarlas